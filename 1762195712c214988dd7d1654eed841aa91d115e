{
  "comments": [
    {
      "key": {
        "uuid": "7a6b29fe_17a7810d",
        "filename": "inject/inject/src/main/java/org/opendaylight/infrautils/inject/LifecycleSupport.java",
        "patchSetId": 8
      },
      "lineNbr": 28,
      "author": {
        "id": 1842
      },
      "writtenOn": "2016-08-23T16:39:28Z",
      "side": 1,
      "message": "This needs to be volatile since it\u0027s accessed unsynchronized by isRunning.",
      "revId": "1762195712c214988dd7d1654eed841aa91d115e",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a6b29fe_f75c85ef",
        "filename": "inject/inject/src/main/java/org/opendaylight/infrautils/inject/LifecycleSupport.java",
        "patchSetId": 8
      },
      "lineNbr": 28,
      "author": {
        "id": 5867
      },
      "writtenOn": "2016-08-23T17:11:20Z",
      "side": 1,
      "message": "Right. (Does this sort of stuff just jump out at you, or do you use any tools which we shold propagate more? Can FindBugs spot this??) It be OK to make isRunning() sychronized as well, right?  Is one approache better than the other? Just trying to learning something myself as well.. ;-)",
      "parentUuid": "7a6b29fe_17a7810d",
      "revId": "1762195712c214988dd7d1654eed841aa91d115e",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a6b29fe_774515b2",
        "filename": "inject/inject/src/main/java/org/opendaylight/infrautils/inject/LifecycleSupport.java",
        "patchSetId": 8
      },
      "lineNbr": 28,
      "author": {
        "id": 1842
      },
      "writtenOn": "2016-08-23T18:32:43Z",
      "side": 1,
      "message": "I have years of experience with Java threading and concurrency - I just know what to look for - a lot of it learned the hard way :)  synchronized incurs an exclusive lock so is much more expensive than a volatile read. You can use an Atomic instead of synchronized in start/stop, either AtomicReference\u003cState\u003e or simplify to AtomicBoolean since there\u0027s only 2 states. \n\nIn the start method:\n\n  if(started.compareAndSet(false, true)) {\n      startWithException();\n      ...\n  } else {\n      LOG.warn(\"Lifecycled object already started; ignoring start()\");\n  }\n\nSimilar for stop.",
      "parentUuid": "7a6b29fe_f75c85ef",
      "revId": "1762195712c214988dd7d1654eed841aa91d115e",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a6b29fe_cdbd786a",
        "filename": "inject/inject/src/main/java/org/opendaylight/infrautils/inject/LifecycleSupport.java",
        "patchSetId": 8
      },
      "lineNbr": 30,
      "author": {
        "id": 5703
      },
      "writtenOn": "2016-08-24T07:04:09Z",
      "side": 1,
      "message": "The name of this method is not readable. It sounds like an Exception already happen when you have a method named startWithException().",
      "revId": "1762195712c214988dd7d1654eed841aa91d115e",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7a6b29fe_8dab801c",
        "filename": "inject/inject/src/main/java/org/opendaylight/infrautils/inject/SingletonWithLifecycle.java",
        "patchSetId": 8
      },
      "lineNbr": 25,
      "author": {
        "id": 5703
      },
      "writtenOn": "2016-08-24T07:04:09Z",
      "side": 1,
      "message": "Did you verify that if you extend this class, and add @Inject on your constructor, everything still works as expected? I have some bad experience doing these things in JBoss, so it\u0027s important to verify.",
      "revId": "1762195712c214988dd7d1654eed841aa91d115e",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}